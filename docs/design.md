# GraphWeaver Design

The API design for GraphWeaver has been considered by focusing on a junior developer persona. This means that many of the design decisions are made with this person in mind.

When reading the document, consider your first experience as a developer. You may not have fully understood all the acronyms and terminology. Therefore, this API is designed to have a high level of readability and extensibility.

## Design Principles

- We prefer verbosity over terseness.
- We adopt an extensible approach

These principles introduce some negative consequences. For example, senior software engineers may find this frustrating as they have to type more boilerplate to interact with the API.

This is apparent when writing filters. Filters use a convention such as:

```
{
  firstName: {
    "equals": "Luke"
  }
}
```

This could be shortened to `firstName_eq: "Luke"` however, you have to know what `_eq` means and this approach is less extensible.

When working on GraphWeaver remember when you were a junior developer and ask yourself. Would I know what this means?

## Lists

Each entity will create two query types an individual query by identifier and a list query.

For example, if we have an Author entity, the queries generated by Base Resolver would look like this:

```
author(id:ID!): Author
authors(filter: AuthorFilter, pagination: Pagination): [Author]
```

Let's take a closer look at Filters.

### Filters

Filters are a combination of logical and conditional operators. These operators are combinable and offer great flexibility and power. We must remember that they also introduce a learning curve for new developers.

It is the design intention to not couple these operators too closely with SQL operators. Although the comparison is inevitable different data sources will support either all or a subset of the operations.

The operators supported by base resolver are:

#### Logical Operators

| Operator | Description                               |
| -------- | ----------------------------------------- |
| and      | All conditions must return `true`         |
| or       | One or more conditions must return `true` |
| not      | All conditions must return `false`        |

#### Conditional Operators

| Operator           | Description                                |
| ------------------ | ------------------------------------------ |
| equals             | Value equals `n`                           |
| in                 | Value `n` exists in the list               |
| lessThan           | Value `n` is less than `x`                 |
| lessThanOrEqual    | Value `n` is less than or equal to `x`     |
| greaterThan        | Value `n` is greater than `x`              |
| greaterThanOrEqual | Value `n` is greater than or equal to `x`  |
| startsWith         | Value `n` starts with `x`                  |
| endsWith           | Value `n` ends with `x`                    |
| contains           | Value `n` contains `x`                     |
| case               | a modifier that specifies case sensitivity |

The last conditional operator is a bit different to the others. It modifies how the conditional operator is applied. The `case` operator looks like this:

```
 enum Case {
    SENSITIVE
    INSENSITIVE
  }
```

And specifies if the case sensitivity for string-based filters should be applied. Next, let's look at the filters that are created by Base Resolver.

Base Resolver produces four Filter types:

- IdFilter
- StringFilter
- NumberFilter
- DateFilter

Each filter above will only support a subset of the operators. For example, string filters will not support `lessThan`. Here is the schema output for each filter:

#### IdFilter

```
  input IdFilter {
    not: [IdFilter!]
    equal: String
    in: [String!]
  }
```

#### StringFilter

```
  input StringFilter {
    not: [StringFilter!]
    equal: String
    in: [String!]
    startsWith: String
    endsWith: String
    contains: String
    case: Case
  }
```

#### NumberFilter

```
  input NumberFilter {
    not: [NumberFilter!]
    equal: Float
    in: [Float!]
    lessThan: Float
    lessThanOrEqual: Float
    greaterThan: Float
    greaterThanOrEqual: Float
  }
```

#### DateFilter

```
  input DateFilter {
    not: [DateFilter!]
    equal: DateTime
    in: [DateTime!]
    lessThan: DateTime
    lessThanOrEqual: DateTime
    greaterThan: DateTime
    greaterThanOrEqual: DateTime
  }
```

Next, let's look at some sample filters.

#### Filter Test Cases

- Where Author's first name equals "Luke"

```
{
  firstName: {
    "equal": "Luke"
  }
}
```

- Where Author's first name starts with "L"

```
{
  firstName: {
    "startsWith": "L"
  }
}
```

- Where Author's first name ends with "ke"

```
{
  firstName: {
    "endsWith": "ke"
  }
}
```

- Where Author's first name contains "uk"

```
{
  firstName: {
    "contains": "uk"
  }
}
```

- Where Author's first name is null

```
{
  firstName: {
    "equal": null
  }
}
```

- Where Author's first name starts with "Luk" and is case sensitive

```
{
  firstName: {
    "startsWith": "Luk",
    "case": "sensitive"
  }
}
```

One area that we have not covered yet is the use of `not`. Let's look at that next.

#### Not Logical Operator

You may have noticed that there is not a specific `notIn` or `notEqual` operator. This is because there is a `not` logical operator that we can use instead. Let's look at some examples:

- Where Author's first name is not "Luke"

```
{
  firstName: {
    "not": [
      {
        "equal": "Luke"
      }
    ]
  }
}
```

- Where Author's first name is not "Luke" and any case

```
{
  firstName: {
    "not": [
      {
        "equal": "Luke",
        "case": "insensitive"
      }
    ]
  }
}
```

- Where Author's first name is not null

```
{
  firstName: {
    "not": [
      {
        "equal": null
      }
    ]
  }
}
```

- Where Author's id is not in

```
{
  id: {
    "not": [
      {
        "in": ["1"]
      }
    ]
  }
}
```

The not logical operator can be used to reverse a the default behavior from "All conditions must return `true`" to "All conditions must return `false`".

### Pagination
