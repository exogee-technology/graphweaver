# GraphWeaver API Design

The GraphWeaver API is designed for a junior developer starting as a software engineer. All design decisions have this junior developer in mind.

When reading the document, consider your first experience as a developer. You may not have fully understood all the acronyms and terminology. Therefore the design of this API has a high level of readability.

- [GraphWeaver API Design](#graphweaver-api-design)
  - [Design Principles](#design-principles)
  - [Lists](#lists)
    - [Filters](#filters)
      - [Operators](#operators)
        - [Logical Operators](#logical-operators)
        - [Conditional Operators](#conditional-operators)
        - [Not Logical Operator](#not-logical-operator)
      - [Scalar Filters](#scalar-filters)
        - [IdFilter](#idfilter)
        - [StringFilter](#stringfilter)
        - [NumberFilter](#numberfilter)
        - [DateFilter](#datefilter)
      - [Filter Test Cases](#filter-test-cases)
    - [Pagination](#pagination)
      - [OrderBy](#orderby)

## Design Principles

The API design has some guiding principles:

- We prefer verbosity to improve readability.
- We adopt an extensible approach to reduce refactoring.

As software engineers, we spend more time reading code than writing it. Therefore, the API focuses on readability, limiting the number of acronyms and/or abbreviations.

The second principle is about extensibility. Many companies and projects will use this API, it is impossible to know their requirements from the start. However, we can allow the API to be easily extensible, saving us refactoring time in the future.

We should follow these principles when proposing changes to the API.

We also acknowledge that these principles introduce some negative consequences. For example, senior software engineers may find this frustrating as they have to type more boilerplate to interact with the API.

This frustration is apparent when writing filters. Filters use a convention such as:

```
{
  firstName: {
    "equals": "Luke"
  }
}
```

We could shorten it to `firstName_eq: "Luke"` yet, you have to know what `_eq` means. This approach is also less extensible if we needed to add in a case insensitive equals operator.

When working on GraphWeaver, remember when you were a junior developer and ask yourself. Would I know what this means?

Let us start with the design for Lists.

## Lists

Each entity will create two query types, an individual query by identifier and a list query.

For example, if we have an Author entity, the queries generated by GraphWeaver would look like this:

```
author(id:ID!): Author
authors(filter: AuthorFilter!, pagination: Pagination): AuthorList
```

You might have noticed in the above there is also an `AuthorList` type. The `AuthorList` is a`List` type and contains this schema:

```
  type AuthorList {
    items: [Author]
    count: Int
  }
```

The `AuthorList` has two returned properties `items`, an array of authors and a `count` property. The `count` property is the total number of authors in the dataset and is useful when you need to display how many authors there are in the system.

An example list query would look like this:

```
query {
  authors (filter: {id: {equal: "1"} }, pagination: { limit: 2} ) {
    items {
      id
      firstName
    }
    count
  }
}
```

We can use the `count` property when implementing paging, which we will cover in more detail later. Next, let's take a closer look at filters.

### Filters

Filters are a combination of logical and conditional operators. These operators are composable and offer great flexibility and power. We must remember that they also introduce a learning curve for new developers.

#### Operators

It is the design intention to decouple these operators from SQL operators. Although the comparison is inevitable different data sources will support either a subset or all operations.

The operators supported by base resolver are:

##### Logical Operators

| Operator | Description                               |
| -------- | ----------------------------------------- |
| and      | All conditions must return `true`         |
| or       | One or more conditions must return `true` |
| not      | All conditions must return `false`        |

##### Conditional Operators

| Operator           | Description                                |
| ------------------ | ------------------------------------------ |
| equals             | Value equals `n`                           |
| in                 | Value `n` exists in the list               |
| lessThan           | Value `n` is less than `x`                 |
| lessThanOrEqual    | Value `n` is less than or equal to `x`     |
| greaterThan        | Value `n` is greater than `x`              |
| greaterThanOrEqual | Value `n` is greater than or equal to `x`  |
| startsWith         | Value `n` starts with `x`                  |
| endsWith           | Value `n` ends with `x`                    |
| contains           | Value `n` contains `x`                     |
| case               | a modifier that specifies case sensitivity |

The last conditional operator is a bit different to the others. It modifies how the conditional operator is applied. The `case` operator is defined like this:

```
 enum Case {
    SENSITIVE
    INSENSITIVE
  }
```

It specifies the case sensitivity for a string-based operator. Next, let's look at the filter types that Base Resolver uses.

##### Not Logical Operator

You may have noticed that there is not a specific `notIn` or `notEqual` conditional operator. That is because there is a `not` logical operator that we can use instead. Let's look at some examples:

- Where Author's first name is not "Luke"

```
{
  firstName: {
    "not": [
      {
        "equal": "Luke"
      }
    ]
  }
}
```

- Where Author's first name is not "Luke" and any case

```
{
  firstName: {
    "not": [
      {
        "equal": "Luke",
        "case": "insensitive"
      }
    ]
  }
}
```

- Where Author's first name is not null

```
{
  firstName: {
    "not": [
      {
        "equal": null
      }
    ]
  }
}
```

- Where Author's id is not in

```
{
  id: {
    "not": [
      {
        "in": ["1"]
      }
    ]
  }
}
```

The `not` logical operator is for reversing the default behaviour from "All conditions must return `true`" to "All conditions must return `false`".

#### Scalar Filters

Base Resolver produces four Scalar Filter types:

- IdFilter
- StringFilter
- NumberFilter
- DateFilter

Each filter will only support a subset of the operators. For example, string filters will not implement `lessThan`. Here is the schema output for each filter:

##### IdFilter

```
  input IdFilter {
    not: [IdFilter!]
    equal: String
    in: [String!]
  }
```

##### StringFilter

```
  input StringFilter {
    not: [StringFilter!]
    equal: String
    in: [String!]
    startsWith: String
    endsWith: String
    contains: String
    case: Case
  }
```

##### NumberFilter

```
  input NumberFilter {
    not: [NumberFilter!]
    equal: Float
    in: [Float!]
    lessThan: Float
    lessThanOrEqual: Float
    greaterThan: Float
    greaterThanOrEqual: Float
  }
```

##### DateFilter

```
  input DateFilter {
    not: [DateFilter!]
    equal: DateTime
    in: [DateTime!]
    lessThan: DateTime
    lessThanOrEqual: DateTime
    greaterThan: DateTime
    greaterThanOrEqual: DateTime
  }
```

Next, let's look at some sample filters.

#### Filter Test Cases

- Where Author's first name equals "Luke"

```
{
  firstName: {
    "equal": "Luke"
  }
}
```

- Where Author's first name starts with "L"

```
{
  firstName: {
    "startsWith": "L"
  }
}
```

- Where Author's first name ends with "ke"

```
{
  firstName: {
    "endsWith": "ke"
  }
}
```

- Where Author's first name contains "uk"

```
{
  firstName: {
    "contains": "uk"
  }
}
```

- Where Author's first name is null

```
{
  firstName: {
    "equal": null
  }
}
```

- Where Author's first name starts with "Luk" and is case sensitive

```
{
  firstName: {
    "startsWith": "Luk",
    "case": "sensitive"
  }
}
```

We have not covered the use of `not`. Let's look at that next.

### Pagination

GraphWeaver uses offset pagination. In offset pagination, the clients define how many items they would like returned and an offset parameter (or page).

One of the issues with offset pagination is that you can get duplicated results if new data is added to a list while a client is paginating. There are ways to deduplicate on the front end, but it is worth being aware of this limitation.

The schema definition for pagination looks like this:

```
  enum SORT {
    ASC
    DESC
  }

  input OrderBy {
    id: SORT
  }

  input Pagination {
    limit: Int
    offset: Int
    orderBy: OrderBy
  }
```

#### OrderBy

The `OrderBy` input type allows us to reorder the paginated results. For example, we might want the most recent book in our system. We could achieve that with:

```
{
  limit: 1,
  offset: 0,
  orderBy: {
    createdAt: DESC
  }
}
```

GraphWeaver generates the `OrderBy` input for each entity type. For example, our book `OrderBy` input would look like this:

```
  input BookOrderBy {
    id: SORT,
    title: SORT,
    createdAt: SORT,
  }
```

This allows us to choose which attribute we would like to order.
