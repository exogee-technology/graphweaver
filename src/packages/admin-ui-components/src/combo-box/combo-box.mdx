import { Canvas, Meta, Story, Controls } from '@storybook/addon-docs/blocks';

import * as ComboBoxStories from './combo-box.stories';
import { ComboBox } from './component';

<Meta of={ComboBoxStories} />

# ComboBox

The ComboBox component combines input and dropdown functionality, allowing users to select from predefined options or filter through them by typing.

## Overview

The ComboBox component is a versatile form control that can be used to:

- Select a single item from a list of options
- Select multiple items from a list of options
- Search and filter through available options by typing
- Display selected item(s) with the ability to remove them

## Examples

### Single Select

Use the single select mode when users should choose only one option.

<Canvas of={ComboBoxStories.SingleSelect} />

### Multi Select

Use the multi select mode when users can choose multiple options.

<Canvas of={ComboBoxStories.MultiSelect} />

### With Pre-selected Values

ComboBoxes can have pre-selected values for both single and multi-select modes.

#### Single Pre-selected Value

<Canvas of={ComboBoxStories.WithSelectedValue} />

#### Multiple Pre-selected Values

<Canvas of={ComboBoxStories.WithMultipleSelectedValues} />

#### Selected Items in Dropdown

When using multi-select mode, selected items appear at the top of the dropdown as purple lozenges. Users can click on individual lozenges to deselect them, and the items will return to the main options list in their original order.

<Canvas of={ComboBoxStories.SelectedItemsInDropdown} />

### States and Variations

#### Loading State

Display a loading spinner when options are being fetched asynchronously.

<Canvas of={ComboBoxStories.Loading} />

#### Disabled State

Prevent user interaction with the disabled state.

<Canvas of={ComboBoxStories.Disabled} />

#### Free Typing

Allow users to type to filter options.

<Canvas of={ComboBoxStories.WithFreeTyping} />

### Lazy Loading with Infinite Scroll

For large datasets, the ComboBox supports lazy loading with infinite scroll. This allows you to fetch data in pages as the user scrolls, improving performance and user experience.

<Canvas of={ComboBoxStories.LazyLoadingWithInfiniteScroll} />

#### Key Features:

- **Data Fetching**: Provide a `dataFetcher` function that returns paginated data
- **Infinite Scroll**: Automatically load more data when the user scrolls near the bottom
- **Search Integration**: Search terms are automatically passed to the data fetcher
- **Debounced Search**: Configurable debounce delay to prevent excessive API calls
- **Loading States**: Visual indicators for when more data is being fetched

#### Implementation:

```tsx
const dataFetcher: DataFetcher = async ({ page, searchTerm }) => {
	const response = await fetch(`/api/items?page=${page}&pageSize=25&search=${searchTerm}`);
	const result = await response.json();

	return result.items || [];
};

<ComboBox
	dataFetcher={dataFetcher}
	searchDebounceMs={300}
	allowFreeTyping={true}
	mode={SelectMode.SINGLE}
	placeholder="Search and scroll to load more..."
/>;
```

### In Form Context

ComboBoxes are typically used within forms to collect user input.

<Canvas of={ComboBoxStories.InForm} />

## Properties

<Controls of={ComboBoxStories.SingleSelect} />

### Lazy Loading Props

When using the lazy loading feature, you can configure these additional properties:

| Prop               | Type          | Default     | Description                                    |
| ------------------ | ------------- | ----------- | ---------------------------------------------- |
| `dataFetcher`      | `DataFetcher` | `undefined` | Function to fetch paginated data               |
| `searchDebounceMs` | `number`      | `300`       | Debounce delay for search input (milliseconds) |

## Usage Guidelines

- Use single select when only one option should be selected at a time
- Use multi select when multiple options can be selected simultaneously
- Provide clear, concise option labels that users can easily understand
- Consider adding free typing capability for long lists to allow filtering
- Use placeholder text to give users a hint about what to select
- Include a loading state for asynchronously loaded options
- For very short lists (2-5 items), consider using radio buttons or checkboxes instead
- **Multi-select UX**: In multi-select mode, selected items appear at the top of the dropdown for easy access and deselection
- **Individual Deselection**: Users can click on individual selected item lozenges to remove them without affecting other selections
- **Order Preservation**: When items are deselected, they return to their original position in the options list
- **Lazy Loading**: Use lazy loading with infinite scroll for datasets with more than 100 items to improve performance
- **Search Integration**: When implementing lazy loading, ensure your data fetcher properly handles search terms for optimal user experience
- **Page Size**: Choose an appropriate page size (typically 20-50 items) in your data fetcher based on your data structure and API capabilities

## Accessibility

- ComboBox is keyboard accessible, allowing for navigation with arrow keys
- Selected pills include keyboard delete functionality (Backspace or Delete keys)
- Focus states are visually distinct for keyboard users
- Dropdown options have visual indication for both focus and selection state
- Component includes proper ARIA roles for better screen reader support
