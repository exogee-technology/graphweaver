import fs from 'fs';
import path from 'path';
import { codegen } from '@graphql-codegen/core';
import { executeCodegen } from '@graphql-codegen/cli';
import nearOperationFilePreset from '@graphql-codegen/near-operation-file-preset';
import typescriptOperations from '@graphql-codegen/typescript-operations';
import typescriptReactApollo from '@graphql-codegen/typescript-react-apollo';
import { GraphQLSchema, buildSchema, printSchema, parse, DocumentNode } from 'graphql';
import * as typescript from '@graphql-codegen/typescript';
import { loadDocuments } from '@graphql-tools/load';
import { CodeFileLoader } from '@graphql-tools/code-file-loader';
import { Source } from '@graphql-tools/utils';
import { glob } from 'glob';

type CodegenOptions = {
	typesOutputPath?: string | string[];
};

type CodegenConfig = { [key: string]: any };

type GeneratedFile = {
	filename: string;
	content: string;
};

const content = `/* eslint-disable */
/* 
* This file is auto-generated by Graphweaver. 
* Please do not edit it directly.
*/`;

const generateCombinedTypeFiles = async (
	config: CodegenConfig,
	schema: DocumentNode,
	documents: Source[]
) => {
	console.info('GENERATING types.ts & types.generated.ts');
	const typesFileContent = await codegen({
		schema,
		documents,
		filename: 'src/types.generated.ts',
		config,
		plugins: [{ typescriptPlugin: {} }],
		pluginMap: {
			typescriptPlugin: typescript,
		},
	});
	fs.writeFileSync('src/types.generated.ts', content.concat('\n', typesFileContent));
	fs.writeFileSync('src/frontend/types.ts', content.concat('\n', typesFileContent));
	console.info('DONE');
};

const generateIndividualTypeFiles = async (
	config: CodegenConfig,
	schema: DocumentNode,
	documents: Source[],
	typesOutputPaths: string[]
) => {
	console.info('PLUCKING GQL');

	const fileList = await glob('./src/**/!(*.generated).{ts,tsx}');

	for (const filename of fileList) {
		console.info('filename', filename);
		const fileparts = filename.split('.') ?? [];
		const outfile = fileparts[0].concat('.generated.', fileparts[1]);
		console.info('outfile', outfile);
		const source: Source = {
			location: filename,
		};

		const fileContent = await codegen({
			plugins: [{ typescriptOperationsPlugin: {} }, { typescriptReactApolloPlugin: {} }],
			schema,
			documents: [source],
			filename: outfile,
			config,
			pluginMap: {
				typescriptOperationsPlugin: typescriptOperations,
				typescriptReactApolloPlugin: typescriptReactApollo,
			},
		});

		typesOutputPaths.forEach((outputPath: string) => {
			console.info(`writing file ${outfile}`);
			fs.writeFileSync(path.join(outputPath, outfile), content.concat('\n', fileContent));
		});
	}

	console.info('DONE');
};

const generateFiles = async (schemaAsString: string, typesOutputPaths: string[]) => {
	console.info('typesOutputPaths', typesOutputPaths);
	const gqlSchema: GraphQLSchema = buildSchema(schemaAsString);
	const schema = parse(printSchema(gqlSchema));

	const config = {
		skipDocumentsValidation: {
			skipDuplicateValidation: true, // A flag to disable the validation for duplicate query and mutation names we don't need this as we are using near-operation-file
		},
	};

	let documents: Source[] | undefined = undefined;
	try {
		console.info('STARTING TO GENERATE FILES');
		documents = await loadDocuments('./src/**/!(*.generated).{ts,tsx}', {
			loaders: [new CodeFileLoader()],
		});
	} catch (e) {
		documents = [];
	}

	console.info('STARTING TYPE FILES');
	await generateCombinedTypeFiles(config, schema, documents);
	await generateIndividualTypeFiles(config, schema, documents, typesOutputPaths);
};

export const codeGenerator = async (schema: string, options?: CodegenOptions) => {
	try {
		const typesOutputPaths = formatListOfTypeOutputPaths(options?.typesOutputPath);
		await generateFiles(schema, typesOutputPaths);
	} catch (err: any) {
		const defaultStateMessage = `Unable to find any GraphQL type definitions for the following pointers:`;
		if (err.message && err.message.includes(defaultStateMessage)) {
			// do nothing for now and silently fail
		} else {
			console.log(err.message + `\n in ${err.source?.name}`);
		}
	}
};

export const codeGenerator1 = async (schema: string, options?: CodegenOptions) => {
	try {
		const files = await executeCodegen({
			cwd: process.cwd(),
			pluginLoader: async (plugin: string) => import(plugin),
			schema,
			ignoreNoDocuments: true,
			documents: ['./src/**/!(*.generated).{ts,tsx}'],
			generates: {
				'src/types.generated.ts': {
					config: {
						skipDocumentsValidation: {
							skipDuplicateValidation: true, // A flag to disable the validation for duplicate query and mutation names we don't need this as we are using near-operation-file
						},
					},
					plugins: [
						{
							add: {
								content,
							},
						},
						'typescript',
					],
				},
				'src/': {
					preset: nearOperationFilePreset,
					presetConfig: {
						extension: '.generated.ts',
						baseTypesPath: 'types.generated.ts',
					},
					plugins: [
						{
							add: {
								content,
							},
						},
						'typescript-operations',
						'typescript-react-apollo',
					],
				},
			},
		});

		const typesOutputPaths = formatListOfTypeOutputPaths(options?.typesOutputPath);

		// Write the files to disk
		const writeOperations = files.flatMap((file) => [
			fs.promises.writeFile(path.join(file.filename), file.content, 'utf8'),
			// We save the types to two locations src and .graphweaver / outdir
			...(file.filename === 'src/types.generated.ts'
				? typesOutputPaths.map((outputPath: string) =>
						fs.promises.writeFile(outputPath, file.content, 'utf8')
				  )
				: []),
		]);

		// Write the files to disk
		await Promise.all(writeOperations);
	} catch (err: any) {
		const defaultStateMessage = `Unable to find any GraphQL type definitions for the following pointers:`;
		if (err.message && err.message.includes(defaultStateMessage)) {
			// do nothing for now and silently fail
		} else {
			console.log(err.message + `\n in ${err.source?.name}`);
		}
	}
};

const formatListOfTypeOutputPaths = (typesOutputPath?: string | string[]) => {
	const typesOutput = ['./src/frontend/types.ts'];

	// If the typesOutputPath is a string or an array of strings, add it to the typesOutput array
	if (typesOutputPath && typeof typesOutputPath === 'string') {
		typesOutput.push(typesOutputPath);
	}
	if (typesOutputPath && Array.isArray(typesOutputPath)) {
		typesOutput.push(...typesOutputPath);
	}

	// Ensure that all paths have a filename and add one if it does not exist
	typesOutput.forEach((filepath, index) => {
		if (!filepath.includes('.ts')) {
			typesOutput[index] = path.join(filepath, '/types.ts');
		}
	});

	// Ensure that the typesOutput directories exist
	console.log('Generating types in the following paths:');
	for (const outputPath of typesOutput) {
		const dirPath = path.dirname(path.join(process.cwd(), outputPath));
		if (!fs.existsSync(dirPath)) {
			fs.mkdirSync(dirPath, { recursive: true });
		}

		console.log(dirPath);
	}

	return typesOutput;
};
